use std::{
    cell::UnsafeCell,
    collections::HashSet,
    fmt::Debug,
    time::{Duration, Instant},
};

use quiche::Connection;

use crate::{
    poll::{Error, Event, EventKind, Result},
    utils::min_of_some,
};

/// Internal lock for one `ConnState`
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
pub enum Lockind {
    /// Lock is released.
    None,
    /// Lock for `send` operation.
    Send,
    /// Lock for `recv` operation.
    Recv,
    /// Lock for `close` operation.
    Close,
    /// Lock for `stream_open` operation.
    StreamOpen,
    /// Lock for `stream_send` operation.
    StreamSend(u64, usize),
    /// Lock for `stream_recv` operation.
    StreamRecv(u64),
    /// Lock for `stream_shutdown` operation.
    StreamShutdown,
}

impl Lockind {
    pub fn need_retry(&self) -> bool {
        match self {
            Lockind::None | Lockind::StreamShutdown | Lockind::Close | Lockind::Send => false,
            _ => true,
        }
    }
}

/// A lock guard for `ConnState`
pub struct ConnStateGuard {
    pub lock_count: u64,
    pub conn: &'static mut Connection,
}

impl Debug for ConnStateGuard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ConnStateGuard")
            .field("lock_count", &self.lock_count)
            .finish()
    }
}

/// Inner state of one `quiche::Connection` managed by `Poll` instance.
pub struct ConnState {
    /// Local id generated by `Poll`.
    id: u32,
    /// Wrapped `quiche::Connection`
    conn: UnsafeCell<quiche::Connection>,
    /// current lock state.
    lock: Lockind,
    /// lock requests that need to retry.
    retry_lock_requests: HashSet<Lockind>,
    /// The count of lock times used as lock tracking handle.
    lock_count: u64,
    /// Record the next locally opened bi-directional stream id
    #[allow(unused)]
    local_bidi_stream_id_next: u64,
    /// release timer threshold
    release_timer_threshold: Duration,
}

impl ConnState {
    /// Wrap a new `quiche::Connection`
    pub fn new(id: u32, release_timer_threshold: Duration, conn: quiche::Connection) -> Self {
        Self {
            id,
            local_bidi_stream_id_next: if conn.is_server() { 5 } else { 4 },
            conn: UnsafeCell::new(conn),
            lock: Lockind::None,
            retry_lock_requests: Default::default(),
            lock_count: 0,
            release_timer_threshold,
        }
    }

    /// Try lock this `state`.
    ///
    /// Safety:
    /// - This function is protected by an upper-level spin-lock.
    /// - Only one specific thread own the returns `&'static mut Connection` at the same time.
    pub fn try_lock(&mut self, kind: Lockind) -> Result<ConnStateGuard> {
        assert_ne!(kind, Lockind::None, "Lockind is None.");
        // The resource is busy.
        if self.lock != Lockind::None {
            // retry this operation later.
            if kind.need_retry() {
                self.retry_later(kind);
            }

            return Err(Error::Busy);
        }

        // Successfully locked this state.
        self.lock = kind;

        // Upper level code needs to be careful to save the trace handle, which is needed to call `unlock`.
        Ok(ConnStateGuard {
            lock_count: self.lock_count,
            conn: unsafe { self.conn.get().as_mut().unwrap() },
        })
    }

    /// Unlock this state with `lock_count` returned by `try_lock`.
    ///
    /// Returns when the next timeout event will occur.
    ///
    /// Safety:
    /// - This function is protected by an upper-level spin-lock.
    pub fn unlock<F>(&mut self, lock_count: u64, mut f: F)
    where
        F: FnMut(Event),
    {
        assert_ne!(self.lock, Lockind::None, "Unlock a released stat.");
        assert_eq!(self.lock_count, lock_count, "`lock_count` is mismatched.");

        self.lock = Lockind::None;
        // step `lock_count`
        self.lock_count += 1;

        // Safety:
        // - only one thread can access this code at the same time.
        let conn = unsafe { self.as_mut() };

        // check `peer_streams_left_bidi`
        if self.retry_lock_requests.remove(&Lockind::StreamOpen) {
            if conn.peer_streams_left_bidi() > 0 {
                f(Event {
                    kind: EventKind::StreamOpen,
                    lock_released: true,
                    is_error: false,
                    conn_id: self.id,
                    // unset.
                    stream_id: 0,
                    release_time: None,
                });
            }
        }

        for kind in self.retry_lock_requests.drain() {
            match kind {
                Lockind::Send => {
                    // We use `get_next_release_time` to determine if the connection has data to send.
                }
                Lockind::Recv => {
                    f(Event {
                        kind: EventKind::Recv,
                        lock_released: true,
                        is_error: false,
                        conn_id: self.id,
                        // unset.
                        stream_id: 0,
                        release_time: None,
                    });
                }
                Lockind::StreamSend(stream_id, len) => {
                    // such that it is not going to be
                    // reported as writable again by [`stream_writable_next()`] until its send
                    // capacity reaches `len`.
                    match conn.stream_writable(stream_id, len) {
                        Ok(writable) => {
                            if writable {
                                f(Event {
                                    kind: EventKind::StreamSend,
                                    lock_released: true,
                                    is_error: false,
                                    conn_id: self.id,
                                    stream_id,
                                    release_time: None,
                                });
                            }
                        }
                        Err(err) => {
                            log::error!(
                                "failed to call `stream_writable`, scid={:?}, id={}, err={}",
                                conn.trace_id(),
                                stream_id,
                                err
                            );

                            f(Event {
                                kind: EventKind::StreamSend,
                                lock_released: true,
                                is_error: true,
                                conn_id: self.id,
                                stream_id,
                                release_time: None,
                            });
                        }
                    }
                }
                Lockind::StreamRecv(stream_id) => {
                    if conn.stream_readable(stream_id) {
                        f(Event {
                            kind: EventKind::StreamRecv,
                            lock_released: true,
                            is_error: false,
                            conn_id: self.id,
                            stream_id,
                            release_time: None,
                        });
                    }
                }
                _ => {
                    unreachable!("unexpect {:?}", kind)
                }
            }
        }

        while let Some(stream_id) = conn.stream_writable_next() {
            f(Event {
                kind: EventKind::StreamSend,
                lock_released: false,
                is_error: false,
                conn_id: self.id,
                stream_id,
                release_time: None,
            });
        }

        while let Some(stream_id) = conn.stream_readable_next() {
            f(Event {
                kind: EventKind::StreamRecv,
                lock_released: false,
                is_error: false,
                conn_id: self.id,
                stream_id,
                release_time: None,
            });
        }

        let now = Instant::now();

        // check if the connection has data to send.
        //
        let release_time = min_of_some(
            conn.timeout_instant(),
            conn.get_next_release_time()
                .and_then(|release| release.time(now)),
        );

        // check with `release_timer_threshold`
        let release_time = release_time.filter(|time| {
            time.checked_duration_since(now).unwrap_or_default() > self.release_timer_threshold
        });

        f(Event {
            kind: EventKind::Send,
            lock_released: false,
            is_error: false,
            conn_id: self.id,
            stream_id: 0,
            release_time,
        });
    }

    #[inline]
    fn retry_later(&mut self, kind: Lockind) {
        self.retry_lock_requests.insert(kind);
    }

    /// Careful use this function.
    #[inline]
    unsafe fn as_mut(&self) -> &'static mut Connection {
        unsafe { self.conn.get().as_mut().unwrap() }
    }
}

#[cfg(test)]
mod tests {

    use quiche::Config;

    use super::*;

    #[test]
    fn test_lock() {
        let scid = quiche::ConnectionId::from_ref(b"");
        let mut state = ConnState::new(
            0,
            Duration::from_micros(250),
            quiche::connect(
                None,
                &scid,
                "127.0.0.1:1".parse().unwrap(),
                "127.0.0.1:2".parse().unwrap(),
                &mut Config::new(quiche::PROTOCOL_VERSION).unwrap(),
            )
            .unwrap(),
        );

        let guard = state.try_lock(Lockind::Send).unwrap();
        assert_eq!(guard.lock_count, 0);

        assert_eq!(
            state.try_lock(Lockind::Recv).expect_err("Busy"),
            Error::Busy
        );

        assert_eq!(
            state.try_lock(Lockind::StreamOpen).expect_err("Busy"),
            Error::Busy
        );

        assert_eq!(
            state.try_lock(Lockind::StreamRecv(5)).expect_err("Busy"),
            Error::Busy
        );

        let mut events = vec![];

        state.unlock(guard.lock_count, |event| {
            events.push(event);
        });

        assert_eq!(events[0].kind, EventKind::Recv);

        let guard = state.try_lock(Lockind::Recv).expect("Lockind::Recv");
        assert_eq!(guard.lock_count, 1, "step `lock_count`");
    }
}
